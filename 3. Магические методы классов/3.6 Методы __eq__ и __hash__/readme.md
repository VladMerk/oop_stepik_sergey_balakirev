## Магические методы \_\_eq__ и \_\_hash__

**Подвиг 4.** (task_1.py)

Объявите в программе класс с именем Rect (прямоугольник), объекты которого создаются командой:

    rect = Rect(x, y, width, height)

где <u>x, y</u> - координата верхнего левого угла (числа: целые или вещественные); <u>width, height</u> - ширина и высота прямоугольника (числа: целые или вещественные).

В этом классе определите магический метод, чтобы хэши объектов класса Rect с равными width, height были равны. Например:

    r1 = Rect(10, 5, 100, 50)
    r2 = Rect(-10, 4, 100, 50)

    h1, h2 = hash(r1), hash(r2)   # h1 == h2

P.S. На экран ничего выводить не нужно, только объявить класс.

---

**Подвиг 6.** (task_2.py)

Объявите класс с именем ShopItem (товар), объекты которого создаются командой:

    item = ShopItem(name, weight, price)

где <u>name</u> - название товара (строка); <u>weight</u> - вес товара (число: целое или вещественное); <u>price</u> - цена товара (число: целое или вещественное).

Определите в этом классе магические методы:

\_\_hash__() - чтобы товары с одинаковым названием (без учета регистра), весом и ценой имели бы равные хэши;\
\_\_eq__() - чтобы объекты с одинаковыми хэшами были равны.

Затем, из входного потока прочитайте строки командой:

    lst_in = list(map(str.strip, sys.stdin.readlines()))

Строки имеют следующий формат:

название товара 1: вес_1 цена_1
...
название товара N: вес_N цена_N

Например:

Системный блок: 1500 75890.56
Монитор Samsung: 2000 34000
Клавиатура: 200.44 545
Монитор Samsung: 2000 34000

Как видите, товары в этом списке могут совпадать.

Необходимо для всех этих строчек сформировать соответствующие объекты класса ShopItem и добавить в словарь с именем shop_items. Ключами словаря должны выступать сами объекты, а значениями - список в формате:

[item, total]

где <u>item</u> - объект класса ShopItem; <u>total</u> - общее количество одинаковых объектов (с одинаковыми хэшами). Подумайте, как эффективно программно наполнять такой словарь, проходя по списку lst_in один раз.

P.S. На экран ничего выводить не нужно, только объявить класс и сформировать словарь.

**Sample Input:**

    Системный блок: 1500 75890.56
    Монитор Samsung: 2000 34000
    Клавиатура: 200.44 545
    Монитор Samsung: 2000 34000

**Sample Output:**

---

**Подвиг 7.** (task_3.py)

Объявите класс с именем DataBase (база данных - БД), объекты которого создаются командой:

    db = DataBase(path)

где path - путь к файлу с данными БД (строка).

Также в классе DataBase нужно объявить следующие методы:

<u>write(self, record)</u> - для добавления новой записи в БД, представленной объектом record;\
<u>read(self, pk)</u> - чтение записи из БД (возвращает объект Record) по ее уникальному идентификатору pk (уникальное целое положительное число); запись ищется в значениях словаря (см. ниже)

Каждая запись БД должна описываться классом Record, а объекты этого класса создаваться командой:

    record = Record(fio, descr, old)

где fio - ФИО некоторого человека (строка); descr - характеристика человека (строка); old - возраст человека (целое число).

В каждом объекте класса Record должны формироваться следующие локальные атрибуты:

pk - уникальный идентификатор записи (число: целое, положительное); формируется автоматически при создании каждого нового объекта;\
fio - ФИО человека (строка);\
descr - характеристика человека (строка);\
old - возраст человека (целое число).

Реализовать для объектов класса Record вычисление хэша по атрибутам: fio и old (без учета регистра). Если они одинаковы для разных записей, то и хэши должны получаться равными. Также для объектов класса Record  с одинаковыми хэшами оператор == должен выдавать значение True, а с разными хэшами - False.

Хранить записи в БД следует в виде словаря **dict_db** (атрибут объекта db класса DataBase), ключами которого являются объекты класса Record, а значениями список из объектов с равными хэшами:

    dict_db[rec1] = [rec1, rec2, ..., recN]

где rec1, rec2, ..., recN - объекты класса Record с одинаковыми хэшами.

Для наполнения БД прочитайте строки из входного потока с помощью команды:

    lst_in = list(map(str.strip, sys.stdin.readlines()))

где каждая строка представлена в формате:

    "ФИО; характеристика; возраст"

Например:
```
Балакирев С.М.; программист; 33
Кузнецов А.В.; разведчик-нелегал; 35
Суворов А.В.; полководец; 42
Иванов И.И.; фигурант всех подобных списков; 26
Балакирев С.М.; преподаватель; 37
```
Каждая строка должна быть представлена объектом класса Record и записана в БД db (в словарь db.dict_db).

P.S. На экран ничего выводить не нужно.

Sample Input:
```
Балакирев С.М.; программист; 33
Кузнецов Н.И.; разведчик-нелегал; 35
Суворов А.В.; полководец; 42
Иванов И.И.; фигурант всех подобных списков; 26
Балакирев С.М.; преподаватель; 33
```
Sample Output:

---

**Подвиг 8.** (task_4.py)

Из входного потока необходимо прочитать список строк командой:

    lst_in = list(map(str.strip, sys.stdin.readlines()))

Каждая строка содержит информацию об учебном пособии в формате:

*"Название; автор; год издания"*

Например:
```
Python; Балакирев С.М.; 2020
Python ООП; Балакирев С.М.; 2021
Python ООП; Балакирев С.М.; 2022
Python; Балакирев С.М.; 2021
```
Необходимо каждую из этих строк представить объектом класса BookStudy, которые создаются командой:

    bs = BookStudy(name, author, year)

где name - название пособия (строка); author - автор пособия (строка); year - год издания (целое число). Такие же публичные локальные атрибуты должны быть в объектах класса BookStudy.

Для каждого объекта реализовать вычисление хэша по двум атрибутам: name и author (без учета регистра).

Сформировать список lst_bs из объектов класса BookStudy на основе прочитанных строк (списка lst_in). После этого определить число книг с уникальными хэшами. Это число сохранить через переменную unique_books (целое число).

P.S. На экран ничего выводить не нужно.

**Sample Input:**
```
Python; Балакирев С.М.; 2020
Python ООП; Балакирев С.М.; 2021
Python ООП; Балакирев С.М.; 2022
Python; Балакирев С.М.; 2021
```
**Sample Output:**

---

**Подвиг 9 (релакс).** (task_5.py)

Объявите класс с именем *Dimensions*, объекты которого создаются командой:

    d = Dimensions(a, b, c)

где a, b, c - положительные числа (целые или вещественные), описывающие габариты некоторого тела: высота, ширина и глубина.

Каждый объект класса Dimensions должен иметь аналогичные публичные атрибуты a, b, c (с соответствующими числовыми значениями). Также для каждого объекта должен вычисляться хэш на основе всех трех габаритов: a, b, c.

С помощью функции input() прочитайте из входного потока строку, записанную в формате:

"a1 b1 c1; a2 b2 c2; ... ;aN bN cN"

Например:

"1 2 3; 4 5 6.78; 1 2 3; 0 1 2.5"

Если какой-либо габарит оказывается отрицательным значением или равен нулю, то при создании объектов должна генерироваться ошибка командой:

    raise ValueError("габаритные размеры должны быть положительными числами")

Сформируйте на основе прочитанной строки список **lst_dims** из объектов класса Dimensions. После этого отсортируйте этот список по возрастанию (неубыванию) хэшей этих объектов так, чтобы объекты с равными хэшами стояли друг за другом.

P.S. На экран ничего выводить не нужно.

Sample Input:

    1 2 3; 4 5 6.78; 1 2 3; 3 1 2.5

Sample Output:

---

**Подвиг 10 (на повторение).** (task_6.py)

Объявите класс с именем Triangle, объекты которого создаются командой:

    tr = Triangle(a, b, c)

где a, b, c - длины сторон треугольника (числа: целые или вещественные). В классе Triangle объявите следующие дескрипторы данных:

a, b, c - для записи и считывания длин сторон треугольника.

При записи нового значения нужно проверять, что присваивается положительное число (целое или вещественное). Иначе, генерируется исключение командой:

    raise ValueError("длины сторон треугольника должны быть положительными числами")

Также нужно проверять, что все три стороны a, b, c могут образовывать стороны треугольника. То есть, должны выполняться условия:

a < b+c; b < a+c; c < a+b

Иначе генерируется исключение командой:

    raise ValueError("с указанными длинами нельзя образовать треугольник")

Наконец, с объектами класса Triangle должны выполняться функции:

<u>len(tr)</u> - возвращает периметр треугольника, приведенный к целому значению с помощью функции int();\
<u>tr()</u> - возвращает площадь треугольника (можно вычислить по формуле Герона: s = sqrt(p * (p-a) * (p-b) * (p-c)), где p - полупериметр треугольника).

P.S. На экран ничего выводить не нужно, только объявить класс Triangle.
