**Подвиг 6.** (task_1.py)

 В программе предполагается реализовать парсер (обработчик) строки с данными string в определенный выходной формат. Для этого объявлен следующий класс:

```python
class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq
```

И предполагается его использовать следующим образом:

    res = Loader.parse_format("4, 5, -6", Factory)

На выходе (в переменной res) ожидается получать список из набора целых чисел. Например, для заданной строки, должно получиться:

    [4, 5, -6]

Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя статическими методами:

build_sequence() - для создания пустого списка (метод возвращает пустой список);\
build_number(string) - для преобразования строки (string) в целое число (метод возвращает полученное целочисленное значение).

Объявите класс с именем Factory, чтобы получать на выходе искомый результат.

P.S. В программе на экран ничего выводить не нужно.

---

**Подвиг 7.** (task_2.py)

 В программе объявлен следующий класс для работы с формами ввода логин/пароль:

```python
class FormLogin:
    def __init__(self, lgn, psw):
        self.login = lgn
        self.password = psw

    def render_template(self):
        return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])
```

Который предполагается использовать следующим образом:

    login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
    html = login.render_template()

Необходимо прописать классы TextInput и PasswordInput, объекты которых формируются командами:

    login = TextInput(name, size)
    psw = PasswordInput(name, size)

В каждом объекте этих классов должны быть следующие локальные свойства:

<u>name</u> - название для поля (сохраняет передаваемое имя, например, "Логин" или "Пароль");\
<u>size</u> - размер поля ввода (целое число, по умолчанию 10).

Также классы TextInput и PasswordInput должны иметь метод:

<u>get_html(self)</u> - возвращает сформированную HTML-строку в формате (1-я строка для класса TextInput ; 2-я - для класса PasswordInput):

```html
<p class='login'><имя поля>: <input type='text' size=<размер поля> />
<p class='password'><имя поля>: <input type='text' size=<размер поля> />
```

Например, для поля login:
```html
<p class='login'>Логин: <input type='text' size=10 />
```
Также классы TextInput и PasswordInput должны иметь метод класса (@classmethod):

<u>check_name(cls, name)</u> - для проверки корректности переданного имя поля (следует вызывать в инициализаторе) по следующим критериям:

- длина имени не менее 3 символов и не более 50;
- в именах могут использоваться только символы русского, английского алфавитов, цифры и пробелы

Если проверка не проходит, то генерировать исключение командой:

    raise ValueError("некорректное поле name")

Для проверки допустимых символов в каждом классе должен быть прописан атрибут CHARS_CORRECT:

```python
CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
CHARS_CORRECT = CHARS + CHARS.upper() + digits
```
По заданию нужно объявить только классы TextInput и PasswordInput с соответствующим функционалом. Более ничего.

P. S. В данном задании получится дублирование кода в классах TextInput и PasswordInput. На данном этапе - это нормально.

---

**Подвиг 8.** (task_3.py)

 Объявите класс CardCheck для проверки корректности информации на пластиковых картах. Этот класс должен иметь следующие методы:

<u>check_card_number(number)</u> - проверяет строку с номером карты и возвращает булево значение True, если номер в верном формате и False - в противном случае. Формат номера следующий: XXXX-XXXX-XXXX-XXXX, где X - любая цифра (от 0 до 9).\
<u>check_name(name)</u> - проверяет строку name с именем пользователя карты. Возвращает булево значение True, если имя записано верно и False - в противном случае.

Формат имени: два слова (имя и фамилия) через пробел, записанные заглавными латинскими символами и цифрами. Например, SERGEI BALAKIREV.

Предполагается использовать класс CardCheck следующим образом (эти строчки в программе не писать):

```python
is_number = CardCheck.check_card_number("1234-5678-9012-0000")
is_name = CardCheck.check_name("SERGEI BALAKIREV")
```

Для проверки допустимых символов в классе должен быть прописан атрибут:

    CHARS_FOR_NAME = ascii_lowercase.upper() + digits

Подумайте, как правильнее объявить методы *check_card_number* и *check_name* (декораторами *@classmethod* и *@staticmethod*).

P.S. В программе только объявить класс. На экран ничего выводить не нужно.

---

**Подвиг 9.** (task_4.py)

 Объявите в программе класс Video с двумя методами:

<u>create(self, name)</u> - для задания имени name текущего видео (метод сохраняет имя name в локальном атрибуте name объекта класса Video);\
<u>play(self)</u> - для воспроизведения видео (метод выводит на экран строку "воспроизведение видео \<name\>").

Объявите еще один класс с именем **YouTube**, в котором объявите два метода (с декоратором *@classmethod*):

<u>add_video(cls, video)</u> - для добавления нового видео (метод помещает объект video класса Video в список);\
<u>play(cls, video_indx)</u> - для проигрывания видео из списка по указанному индексу (индексация с нуля).

(здесь cls - ссылка на класс YouTube). И список (тоже внутри класса YouTube):

videos - для хранения добавленных объектов класса Video (изначально список пуст).

Метод play() класса YouTube должен обращаться к объекту класса Video по индексу списка videos и, затем, вызывать метод play() класса Video.

Методы add_video и play вызывайте напрямую из класса YouTube. Создавать экземпляр этого класса не нужно.

Создайте два объекта **v1 и v2** класса Video, затем, через метод create() передайте им имена "Python" и "Python ООП". После этого с помощью метода add_video класса YouTube, добавьте в него эти два видео и воспроизведите (с помощью метода play класса YouTube) сначала первое, а затем, второе видео.

Sample Input:

Sample Output:

    воспроизведение видео Python
    воспроизведение видео Python ООП

---

**Подвиг 10 (на повторение).** (task_5.py)

 Объявите класс AppStore - интернет-магазин приложений для устройств под iOS. В этом классе должны быть реализованы следующие методы:

<u>add_application(self, app)</u> - добавление нового приложения app в магазин;\
<u>remove_application(self, app)</u> - удаление приложения app из магазина;\
<u>block_application(self, app)</u> - блокировка приложения app (устанавливает локальное свойство blocked объекта app в значение True);
<u>total_apps(self)</u> - возвращает общее число приложений в магазине.

Класс AppStore предполагается использовать следующим образом (эти строчки в программе не писать):

    store = AppStore()
    app_youtube = Application("Youtube")
    store.add_application(app_youtube)
    store.remove_application(app_youtube)

Здесь Application - класс, описывающий добавляемое приложение с указанным именем. Каждый объект класса Application должен содержать локальные свойства:

<u>name</u> - наименование приложения (строка);\
<u>blocked</u> - булево значение (True - приложение заблокировано; False - не заблокировано, изначально False).

Как хранить список приложений в объектах класса AppStore решите сами.

P.S. В программе нужно только объявить классы с указанным функционалом.

---

**Подвиг 11 (на повторение).** (task_6.py)

 Объявите класс для мессенджера с именем Viber. В этом классе должны быть следующие методы:

<u>add_message(msg)</u> - добавление нового сообщения в список сообщений;\
<u>remove_message(msg)</u> - удаление сообщения из списка;\
<u>set_like(msg)</u> - поставить/убрать лайк для сообщения msg (т.е. изменить атрибут fl_like объекта msg: если лайка нет то он ставится, если уже есть, то убирается);\
<u>show_last_message(число)</u> - отображение последних сообщений;\
<u>total_messages()</u> - возвращает общее число сообщений.

Эти методы предполагается использовать следующим образом (эти строчки в программе не писать):

```python
msg = Message("Всем привет!")
Viber.add_message(msg)
Viber.add_message(Message("Это курс по Python ООП."))
Viber.add_message(Message("Что вы о нем думаете?"))
Viber.set_like(msg)
Viber.remove_message(msg)
```

Класс Message (необходимо также объявить) позволяет создавать объекты-сообщения со следующим набором локальных свойств:

<u>text</u> - текст сообщения (строка);\
<u>fl_like</u> - поставлен или не поставлен лайк у сообщения (булево значение True - если лайк есть и False - в противном случае, изначально False);

P.S. Как хранить список сообщений, решите самостоятельно.
