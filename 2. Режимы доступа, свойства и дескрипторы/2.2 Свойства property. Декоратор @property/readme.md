**Подвиг 4.** (task_1.py)

 Объявите в программе класс Car, в котором реализуйте объект-свойство с именем model для записи и считывания информации о модели автомобиля из локальной приватной переменной __model.

Объект-свойство объявите с помощью декоратора @property. Также в объекте-свойстве model должны быть реализованы проверки:

- модель автомобиля - это строка;
- длина строки модели должна быть в диапазоне [2; 100].

Если проверка не проходит, то локальное свойство __model остается без изменений.

Объекты класса Car предполагается создавать командой:

    car = Car()

и далее работа с объектом-свойством, например:

    car.model = "Toyota"

P.S. В программе объявить только класс. На экран ничего выводить не нужно.

---

**Подвиг 5.** (task_2.py)

 Объявите в программе класс WindowDlg, объекты которого предполагается создавать командой:

    wnd = WindowDlg(заголовок окна, ширина, высота)

В каждом объекте класса WindowDlg должны создаваться приватные локальные атрибуты:

__title - заголовок окна (строка);\
__width, __height - ширина и высота окна (числа).

В классе WindowDlg необходимо реализовать метод:

<u>show()</u> - для отображения окна на экране (выводит в консоль строку в формате: "<Заголовок>: <ширина>, <высота>", например "Диалог 1: 100, 50").

Также в классе WindowDlg необходимо реализовать два объекта-свойства:

width - для изменения и считывания ширины окна;\
height - для изменения и считывания высоты окна.

При изменении размеров окна необходимо выполнять проверку:

- переданное значение является целым числом в диапазоне [0; 10000].

Если хотя бы один размер изменился (высота или ширина), то следует выполнить автоматическую перерисовку окна (вызвать метод show()). При начальной инициализации размеров width, height вызывать метод show() не нужно.

P.S. В программе нужно объявить только класс с требуемой функциональностью.

---

**Подвиг 6.** (task_3.py)

 Реализуйте односвязный список (**не список Python, не использовать список Python для хранения объектов**), когда один объект ссылается на следующий и так по цепочке до последнего:

 ![StakObjects](images/stack.png)

Для этого объявите в программе два класса:

StackObj - для описания объектов односвязного списка;\
Stack - для управления односвязным списком.

Объекты класса StackObj предполагается создавать командой:

    obj = StackObj(данные)

Здесь <u>данные</u> - это строка с некоторым содержимым. Каждый объект класса StackObj должен иметь следующие локальные приватные атрибуты:

__data - ссылка на строку с данными, указанными при создании объекта;\
__next - ссылка на следующий объект класса StackObj (при создании объекта принимает значение None).

Также в классе StackObj должны быть объявлены объекты-свойства:

<u>next</u> - для записи и считывания информации из локального приватного свойства __next;\
<u>data</u> - для записи и считывания информации из локального приватного свойства __data.

При записи необходимо реализовать проверку, что __next будет ссылаться на объект класса StackObj или значение None. Если проверка не проходит, то __next остается без изменений.

Класс Stack предполагается использовать следующим образом:

    st = Stack() # создание объекта односвязного списка

В объектах класса Stack должен быть локальный публичный атрибут:

top - ссылка на первый добавленный объект односвязного списка (если список пуст, то top = None).

А в самом классе Stack следующие методы:

<u>push(self, obj)</u> - добавление объекта класса StackObj в конец односвязного списка;\
<u>pop(self)</u> - извлечение последнего объекта с его удалением из односвязного списка;\
<u>get_data(self)</u> - получение списка из объектов односвязного списка (список из строк локального атрибута __data каждого объекта в порядке их добавления, или пустой список, если объектов нет).

Пример использования классов Stack и StackObj (эти строчки в программе писать не нужно):

```python
st = Stack()
st.push(StackObj("obj1"))
st.push(StackObj("obj2"))
st.push(StackObj("obj3"))
st.pop()
res = st.get_data()    # ['obj1', 'obj2']
```

P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

---

**Подвиг 7.** (task_4.py)

 Объявите класс RadiusVector2D, объекты которого должны создаваться командами:

    v1 = RadiusVector2D()        # радиус-вектор с координатами (0; 0)
    v2 = RadiusVector2D(1)       # радиус-вектор с координатами (1; 0)
    v3 = RadiusVector2D(1, 2)    # радиус-вектор с координатами (1; 2)

В каждом объекте класса RadiusVector2D должны формироваться локальные приватные атрибуты:

__x, __y - координаты конца вектора (изначально значения равны 0, если не передано какое-либо другое).

В классе RadiusVector2D необходимо объявить два объекта-свойства:

x - для изменения и считывания локального атрибута __x;\
y - для изменения и считывания локального атрибута __y.

При инициализации и изменении локальных атрибутов, необходимо проверять корректность передаваемых значений:

- значение должно быть числом (целым или вещественным) в диапазоне [MIN_COORD; MAX_COORD].

Если проверка не проходит, то координаты не меняются (напомню, что при инициализации они изначально равны 0). Величины MIN_COORD = -100, MAX_COORD = 1024 задаются как публичные атрибуты класса RadiusVector2D.

Также в классе RadiusVector2D необходимо объявить статический метод:

<u>norm2(vector)</u> - для вычисления квадратической нормы vector - переданного объекта класса RadiusVector2D (квадратическая норма вектора: x*x + y*y).

P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно.

---

**Большой подвиг 8.** (task_5.py)

 Требуется реализовать программу по работе с решающими деревьями:

![РешающиеДеревья](images/решающее%20дерево.png)

Здесь в каждом узле дерева делается проверка (задается вопрос). Если проверка проходит, то осуществляется переход к следующему объекту по левой стрелке (с единицей), а иначе - по правой стрелке (с нулем). И так до тех пор, пока не дойдем до одного из листа дерева (вершины без потомков).

В качестве входных данных используется вектор (список) с бинарными значениями: 1 - да, 0 - нет. Каждый элемент этого списка соответствует своему вопросу (своей вершине дерева), например:

![РешающиеДеревьяХ](images/решающее%20дерево%20x.png)

Далее, этот вектор применяется к решающему дереву, следующим образом. Корневая вершина "Любит Python" с ней связан первый элемент вектора x и содержит значение 1, следовательно, мы переходим по левой ветви. Попадаем в вершину "Понимает ООП". С ней связан второй элемент вектора x со значением 0, следовательно, мы переходим по правой ветви и попадаем в вершину "будет кодером". Так как эта вершина конечная (листовая), то получаем результат в виде строки "будет кодером". По аналогии выполняется обработка вектора x с другими наборами значений 0 и 1.

Для реализации решающих деревьев в программе следует объявить два класса:

**TreeObj** - для описания вершин и листьев решающего дерева;\
**DecisionTree** - для работы с решающим деревом в целом.

В классе DecisionTree должны быть реализованы (по крайне мере) два метода уровня класса (@classmethod):

<u>def predict(cls, root, x)</u> - для построения прогноза (прохода по решающему дереву) для вектора x из корневого узла дерева root.\
<u>def add_obj(cls, obj, node=None, left=True)</u> - для добавления вершин в решающее дерево (метод должен возвращать добавленную вершину - объект класса TreeObj);

В методе add_obj параметры имеют, следующие значения:

obj - ссылка на новый (добавляемый) объект решающего дерева (объект класса TreeObj);\
node - ссылка на объект дерева, к которому присоединяется вершина obj;\
left - флаг, определяющий ветвь дерева (объекта node), к которой присоединяется объект obj (True - к левой ветви; False - к правой).

В классе **TreeObj** следует объявить инициализатор:

    def __init__(self, indx, value=None): ...

где <u>indx</u> - проверяемый в вершине дерева индекс вектора x; value - значение, хранящееся в вершине (принимает значение None для вершин, у которых есть потомки - промежуточных вершин).

При этом, в каждом создаваемом объекте класса TreeObj должны автоматически появляться следующие локальные атрибуты:

indx - проверяемый индекс (целое число);\
value - значение с данными (строка);\
__left - ссылка на следующий объект дерева по левой ветви (изначально None);\
__right - ссылка на следующий объект дерева по правой ветви (изначально None).

Для работы с локальными приватными атрибутами __left и __right необходимо объявить объекты-свойства с именами **left и right.**

Эти классы в дальнейшем предполагается использовать следующим образом (эти строчки в программе не писать):

```python
root = DecisionTree.add_obj(TreeObj(0))
v_11 = DecisionTree.add_obj(TreeObj(1), root)
v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

x = [1, 1, 0]
res = DecisionTree.predict(root, x) # будет программистом
```

P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

---

**Подвиг 9 (на закрепление).** (task_6.py)

 Вам требуется сформировать класс PathLines для описания маршрутов, состоящих из линейных сегментов. При этом каждый линейный сегмент предполагается задавать отдельным классом LineTo. Объекты этого класса будут формироваться командой:

    line = LineTo(x, y)

где x, y - следующая координата линейного участка (начало маршрута из точки 0, 0).

В каждом объекте класса LineTo должны формироваться локальные атрибуты:

x, y - для хранения координат конца линии (начало определяется по координатам предыдущего объекта).

Объекты класса PathLines должны создаваться командами:

    p = PathLines()                   # начало маршрута из точки 0, 0
    p = PathLines(line1, line2, ...)  # начало маршрута из точки 0, 0

где line1, line2, ... - объекты класса LineTo.

Сам же класс PathLines должен иметь следующие методы:

<u>get_path()</u> - возвращает список из объектов класса LineTo (если объектов нет, то пустой список);\
<u>get_length()</u> - возвращает суммарную длину пути (сумма длин всех линейных сегментов);\
<u>add_line(self, line)</u> - добавление нового линейного сегмента (объекта класса LineTo) в конец маршрута.

**Пояснение:** суммарный маршрут - это сумма длин всех линейных сегментов, а длина каждого линейного сегмента определяется как евклидовое расстояние по формуле:

    L = sqrt((x1-x0)^2 + (y1-y0)^2)

где x0, y0 - предыдущая точка маршрута; x1, y1 - текущая точка маршрута.

Пример использования классов (эти строчки в программе писать не нужно):

```python
p = PathLines(LineTo(10, 20), LineTo(10, 30))
p.add_line(LineTo(20, -10))
dist = p.get_length()
```

P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

---

**Подвиг 10 (на закрепление).** (task_7.py)

 Вы создаете телефонную записную книжку. Она определяется классом PhoneBook. Объекты этого класса создаются командой:

    p = PhoneBook()

А сам класс должен иметь следующий набор методов:

<u>add_phone(phone)</u> - добавление нового номера телефона (в список);\
<u>remove_phone(indx)</u> - удаление номера телефона по индексу списка;\
<u>get_phone_list()</u> - получение списка из объектов всех телефонных номеров.

Каждый номер телефона должен быть представлен классом PhoneNumber. Объекты этого класса должны создаваться командой:

    note = PhoneNumber(number, fio)

где <u>number</u> - номер телефона (число) в формате XXXXXXXXXXX (одиннадцати цифр, X - цифра); fio - Ф.И.О. владельца номера (строка).

В каждом объекте класса PhoneNumber должны формироваться локальные атрибуты:

number - номер телефона (число);\
fio - ФИО владельца номера телефона.

Необходимо объявить два класса PhoneBook и PhoneNumber в соответствии с заданием.

Пример использования классов (эти строчки в программе писать не нужно):

```python
p = PhoneBook()
p.add_phone(PhoneNumber(12345678901, "Сергей Балакирев"))
p.add_phone(PhoneNumber(21345678901, "Панда"))
phones = p.get_phone_list()
```

P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.
