**Подвиг 3.** (task_1.py)

 Объявите класс с именем Clock и определите в нем следующие переменные и методы:

- приватная локальная переменная <u>time</u> для хранения текущего времени, целое число (своя для каждого объекта класса Clock с начальным значением 0);
- публичный метод <u>set_time(tm)</u> для установки текущего времени (присваивает значение tm приватному локальному свойству time, если метод check_time(tm) возвратил True);
- публичный метод <u>get_time()</u> для получения текущего времени из приватной локальной переменной time;
- приватный метод класса <u>check_time(tm)</u> для проверки корректности времени в переменной tm (возвращает True, если значение корректно и False - в противном случае).

Проверка корректности выполняется по критерию: tm должна быть целым числом, больше или равна нулю и меньше 100 000.

Объекты класса Clock предполагается использовать командой:

    clock = Clock(время)

Создайте объект clock класса Clock и установите время, равным 4530.

P.S. На экран ничего выводить не нужно.

---

**Подвиг 4.** (task_2.py)

 Объявите класс с именем Money и определите в нем следующие переменные и методы:

- приватная локальная переменная <u>money</u> (целочисленная) для хранения количества денег (своя для каждого объекта класса Money);
- публичный метод <u>set_money(money)</u> для передачи нового значения приватной локальной переменной money (изменение выполняется только если метод *check_money*(money) возвращает значение True);
- публичный метод <u>get_money()</u> для получения текущего объема средств (денег);
- публичный метод <u>add_money(mn)</u> для прибавления средств из объекта mn класса Money к средствам текущего объекта;
- приватный метод класса <u>check_money(money)</u> для проверки корректности объема средств в параметре money (возвращает True, если значение корректно и False - в противном случае).

Проверка корректности выполняется по критерию: параметр money должен быть целым числом, больше или равным нулю.

Пример использования класса Money (эти строчки в программе не писать):

```python
mn_1 = Money(10)
mn_2 = Money(20)
mn_1.set_money(100)
mn_2.add_money(mn_1)
m1 = mn_1.get_money()    # 100
m2 = mn_2.get_money()    # 120
```

---

**Подвиг 6.** (task_3.py)

 Объявите класс Book со следующим набором сеттеров и геттеров:

<u>set_title(self, title)</u> - запись в локальное приватное свойство __title объектов класса Book значения title;\
<u>set_author(self, author)</u> - запись в локальное приватное свойство __author объектов класса Book значения author;\
<u>set_price(self, price)</u> - запись в локальное приватное свойство __price объектов класса Book значения price;\
<u>get_title(self)</u> - получение значения локального приватного свойства __title объектов класса Book;\
<u>get_author(self)</u> - получение значения локального приватного свойства __author объектов класса Book;\
<u>get_price(self)</u> - получение значения локального приватного свойства __price объектов класса Book;

Объекты класса Book предполагается создавать командой:

    book = Book(автор, название, цена)

При этом, в каждом объекте должны создаваться приватные локальные свойства:

__author - строка с именем автора;\
__title - строка с названием книги;\
__price - целое число с ценой книги.

P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

---

**Подвиг 7.** (task_4.py)

 Объявите класс Line для описания линии на плоскости, объекты которого предполагается создавать командой:

    line = Line(x1, y1, x2, y2)

При этом в объекте line должны создаваться следующие приватные локальные свойства:

__x1, __y1 - начальная координата;\
__x2, __y2 - конечная координата.

В самом классе Line должны быть реализованы следующие сеттеры и геттеры:

<u>set_coords(self, x1, y1, x2, y2)</u> - для изменения координат линии;\
<u>get_coords(self)</u> - для получения кортежа из текущих координат линии.

А также метод:

<u>draw(self)</u> - для отображения в консоли списка текущих координат линии (в одну строчку через пробел).

P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

---

**Подвиг 8.** (task_5.py)

 Объявите в программе два класса Point и Rectangle. Объекты первого класса должны создаваться командой:

    pt = Point(x, y)

где x, y - координаты точки на плоскости (целые или вещественные числа). При этом в объектах класса Point должны формироваться следующие локальные свойства:

__x, __y - координаты точки на плоскости.

и один геттер:

<u>get_coords()</u> - возвращение кортежа текущих координат __x, __y

Объекты второго класса Rectangle (прямоугольник) должны создаваться командами:

    r1 = Rectangle(Point(x1, y1), Point(x2, y2))

или

    r2 = Rectangle(x1, y1, x2, y2)

Здесь первая координата (x1, y1) - верхний левый угол, а вторая координата (x2, y2) - правый нижний. При этом, в объектах класса Rectangle (вне зависимости от способа их создания) должны формироваться следующие локальные свойства:

__sp - объект класса Point с координатами x1, y1 (верхний левый угол);\
__ep - объект класса Point с координатами x2, y2 (нижний правый угол).

Также к классе Rectangle должны быть реализованы следующие методы:

<u>set_coords(self, sp, ep)</u> - изменение текущих координат, где sp, ep - объекты класса Point;\
<u>get_coords(self)</u> - возвращение кортежа из объектов класса Point с текущими координатами прямоугольника (ссылки на локальные свойства __sp и __ep);\
<u>draw(self)</u> - отображение в консоли сообщения: "Прямоугольник с координатами: (x1, y1) (x2, y2)". Здесь x1, y1, x2, y2 - соответствующие числовые значения координат.

Создайте объект rect класса Rectangle с координатами (0, 0), (20, 34).

P.S. На экран ничего выводить не нужно.

---

**Большой подвиг 9.** (task_6.py)

 Необходимо реализовать связный список (не список языка Python и не хранить объекты в списке Python), когда объекты класса ObjList связаны с соседними через приватные свойства __next и __prev:

 ![LinkedList](images/linked_list.png)

Для этого объявите класс LinkedList, который будет представлять связный список в целом и иметь набор следующих методов:

<u>add_obj(self, obj)</u> - добавление нового объекта obj класса ObjList в конец связного списка;\
<u>remove_obj(self)</u> - удаление последнего объекта из связного списка;\
<u>get_data(self)</u> - получение списка из строк локального свойства __data всех объектов связного списка.

И в каждом объекте этого класса должны создаваться локальные публичные атрибуты:

<u>head</u> - ссылка на первый объект связного списка (если список пустой, то head = None);
<u>tail</u> - ссылка на последний объект связного списка (если список пустой, то tail = None).

Объекты класса ObjList должны иметь следующий набор приватных локальных свойств:

__next - ссылка на следующий объект связного списка (если следующего объекта нет, то __next = None);\
__prev - ссылка на предыдущий объект связного списка (если предыдущего объекта нет, то __prev = None);\
__data - строка с данными.

Также в классе ObjList должны быть реализованы следующие сеттеры и геттеры:

<u>set_next(self, obj)</u> - изменение приватного свойства __next на значение obj;\
<u>set_prev(self, obj)</u> - изменение приватного свойства __prev на значение obj;\
<u>get_next(self)</u> - получение значения приватного свойства __next;\
<u>get_prev(self)</u> - получение значения приватного свойства __prev;\
<u>set_data(self, data)</u> - изменение приватного свойства __data на значение data;\
<u>get_data(self)</u> - получение значения приватного свойства __data.

Создавать объекты класса ObjList предполагается командой:

    ob = ObjList("данные 1")

А использовать класс LinkedList следующим образом (пример, эти строчки писать в программе не нужно):

```python
lst = LinkedList()
lst.add_obj(ObjList("данные 1"))
lst.add_obj(ObjList("данные 2"))
lst.add_obj(ObjList("данные 3"))
res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']
```

Объявите в программе классы LinkedList и ObjList в соответствии с заданием.

P.S. На экран ничего выводить не нужно.

---

**Подвиг 10 (на повторение).** (task_7.py)

 Объявите класс EmailValidator для проверки корректности email-адреса. Необходимо запретить создание объектов этого класса: при создании экземпляров должно возвращаться значение None, например:

    em = EmailValidator() # None

В самом классе реализовать следующие методы класса (@classmethod):

<u>get_random_email(cls)</u> - для генерации случайного email-адреса по формату: xxxxxxx...xxx@gmail.com, где x - любой допустимый символ в email (латинский буквы, цифры, символ подчеркивания и точка);\
<u>check_email(cls, email)</u> - возвращает True, если email записан верно и False - в противном случае.

Корректность строки email определяется по следующим критериям:

- допустимые символы: латинский алфавит, цифры, символы подчеркивания, точки и собачка @ (одна);
- длина email до символа @ не должна превышать 100 (сто включительно);
- длина email после символа @ не должна быть больше 50 (включительно);
- после символа @ обязательно должна идти хотя бы одна точка;
- не должно быть двух точек подряд.

Также в классе нужно реализовать приватный статический метод класса:

<u>is_email_str(email)</u> - для проверки типа переменной email, если строка, то возвращается значение True, иначе - False.

Метод is_email_str() следует использовать в методе check_email() перед проверкой корректности email. Если параметр email не является строкой, то check_email() возвращает False.

Пример использования класса EmailValidator (эти строчки в программе писать не нужно):

    res = EmailValidator.check_email("sc_lib@list.ru") # True
    res = EmailValidator.check_email("sc_lib@list_ru") # False

P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно.
