**Подвиг 4.** (task_1.py)
Объявите класс с именем MediaPlayer с двумя методами:

open(file) - для открытия медиа-файла с именем file (создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")

Создайте два экземпляра этого класса с именами: media1 и media2. Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):

```
"Воспроизведение filemedia1"
"Воспроизведение filemedia2"
```
---
**Подвиг 5.** (task_2.py)

Объявите класс с именем Graph и методами:

set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
draw() - отображение данных (в том же порядке, что и в списке data)

и атрибутом:

LIMIT_Y = [0, 10]

Метод set_data() должен формировать локальное свойство data объекта класса Graph. Атрибут data должен ссылаться на переданный в метод список. Метод draw() должен выводить на экран список в виде строки из чисел, разделенных пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).

Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:

[10, -5, 100, 20, 0, 80, 45, 2, 5, 7]

Затем, вызовите метод draw() через объект graph_1. На экране должна появиться строка с соответствующим набором чисел, записанных через пробел. Например (вывод без кавычек):

"10 0 2 5 7"

---

**Подвиг 7.** (task_3.py)

 Имеется следующий класс для считывания информации из входного потока:

```python
import sys


class StreamReader:
    FIELDS = ('id', 'title', 'pages')

    def readlines(self):
        lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
        sd = StreamData()
        res = sd.create(self.FIELDS, lst_in)
        return sd, res
```

Которым, затем, можно воспользоваться следующим образом:

```python
sr = StreamReader()
data, result = sr.readlines()
```

Необходимо перед классом StreamReader объявить еще один класс StreamData с методом:

```python
def create(self, fields, lst_values): ...
```

который бы на входе получал кортеж FIELDS из названий локальных атрибутов (передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields и соответствующими значениями из lst_values.

Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.

P.S. В программе нужно дополнительно объявить только класс StreamData. Больше ничего делать не нужно.

Пример входной информации (Sample Input):

```
10
Питон - основы мастерства
512
```

---

**Подвиг 9.**(task_4.py)

 Из входного потока читаются строки данных с помощью команды:

```
lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
```

в формате: id, name, old, salary (записанные через пробел). Например:

```
1 Сергей 35 120000
2 Федор 23 12000
3 Иван 13 1200
...
```

То есть, каждая строка - это элемент списка lst_in.

Необходимо в класс DataBase:

```python
class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')
```

добавить два метода:

*select(self, a, b)* - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам (не id, а **индексам списка**); также учесть, что граница b может превышать длину списка.

*insert(self, data)* - для добавления в список lst_data новых данных из переданного списка строк data;

Каждая запись в списке lst_data должна быть представлена словарем в формате:

>{'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}

Например:

>{'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}

**Примечание:** в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в коллекции FIELDS.

P. S. Ваша задача только добавить два метода в класс DataBase.

**Sample Input:**
```
1 Сергей 35 120000
2 Федор 23 12000
3 Иван 13 1200
```

---

**Подвиг 10.** (task_5.py)

Объявите класс с именем **Translator** (для перевода с английского на русский) со следующими методами:

*add(self, eng, rus)* - для добавления новой связки английского и русского слова (если английское слово уже существует, то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать); если связка eng-rus уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');\
*remove(self, eng)* - для удаления связки по указанному английскому слову;\
*translate(self, eng)* - для перевода с английского на русский (метод должен возвращать список из русских слов, соответствующих переводу английского слова, даже если в списке всего одно слово).

Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, т.е. связки хранить локально внутри экземпляров классов класса Translator.

Создайте экземпляр *tr* класса *Translator* и вызовите метод *add* для следующих связок:

```
tree - дерево
car - машина
car - автомобиль
leaf - лист
river - река
go - идти
go - ехать
go - ходить
milk - молоко
```

Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go. Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:

**Вывод в формате:** идти ехать ходить
